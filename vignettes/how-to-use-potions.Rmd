---
title: "How to use potions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use potions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Basic usage 
`{potions}` is a package for easily storing and retrieving information via 
`options()`. It therefore provides functionality somewhat similar to 
<a href="https://cran.r-project.org/package=settings">settings</a>, but with 
syntax based more closely on 
<a href="https://cran.r-project.org/package=here">here</a>. Unlike, `{here}`,
`{potions}` supports non-standard evaluation, meaning that arguments can be 
passed to `{potions}` without being quoted. The intended use of 
{potions} is for adding novel information to `options()` for use within single 
packages or workflows. It uses three main functions to deliver this 
functionality:

- `brew()` to store data
- `pour()` to retrieve data
- `drain` to clear data

Because `{potions}` uses a novel S3 object for all data
storage, it **never overwrites existing global options**, and is therefore safe
to use without affecting existing workflows. For example, `print.default` takes
it's default `digits` argument from `getOption("digits")`:

```{r}
options("digits") # set to 7 by default
print(pi)
```

If we use `{potions}` to set `digits`, we do not affect this behaviour. Instead,
the user must specifically retrieve data using `pour` for these settings to be 
applied:

```{r}
potions::brew(digits == 3)

print(pi, digits = pour(digits)) # using potions
print(pi) # default is unaffected
```

This feature - i.e. storing data in a novel S3 object - means that `{potions}` 
can distinguish between interactive use in the console versus being called 
within a package. Data can be provided and used independently by multiple 
packages, and in the console, without generating conflicts. 

Options stored using `{potions}` are not persistent across sessions; you will
need to reload options each time you open a new workspace. It is unlikely, 
therefore, that you will need to 'clear' the data stored by `{potions}` at any
point. If you do need to remove data, you can do so using `drain()` (without
any further arguments).

### Avoiding sharing sensitive information
Often it is necessary to share a script, but without sharing certain sensitive
information necessary to run the code. A common example is API keys or other
sensitive information required to download data from a web service. In such 
cases, the default, interactive method of using `brew()` is insufficient, i.e.

```{r eval = FALSE}
# start of script
brew(list("my-secret-key" = "123456")) # shares secret information
```

To avoid this problem, you can instead supply the path to a file containing that
information, i.e.

```{r eval = FALSE}
brew(file = "config.yml") # hides secret information
```
You can then simply add the corresponding filename to your `gitignore`, and your 
script will still run, without sharing sensitive information.

## Using `{potions}` in package development

### Setting up `{potions}` using `onload()`
To use in a package development situation, set `onLoad.R` to
```{r, eval=FALSE}
.onLoad <- function(libname, pkgname) {
  if(pkgname == "packagenamehere") {
    potions::brew(.pkg = "packagenamehere")
  }
}
```
This is important because it tells brew that you are developing a package,
what that package is called, and where future calls to brew from within that
package should place their data.

### `config` files
As mentioned previously, one way to use `{potions}` is via a `config`
file, e.g. a `yaml` file named something like `config.yml` might contain the 
following information:

```{r, eval=FALSE}
name: Martin Westgate
year: 2023
favourite-color: green
```

The 'easiest' place to put the `config` file is in your packages' root 
directory; in which case the options there will be loaded automatically by 
`brew()`. If you use to keep the root directory a bit tidier, you can put it
within a folder in `inst` and provide a relative file path to `brew`, i.e.

```{r, eval=FALSE}
.onLoad <- function(libname, pkgname) {
  if(pkgname == "packagenamehere") {
    potions::brew(file = "./inst/config/config.yml", 
                  .pkg = "packagenamehere")
  }
}
```

### Building a wrapper function
Often in a package you will want users to call your own configuration function,
rather than call `brew()` directly. This provides greater control over the names 
& types (classes) of data stored by `potions`, which in turn gives you - the 
developer - greater certainty when calling those data *within* your package via
`pour()`.

For example, you might want to specify that a specific argument is supplied as 
numeric:

```{r, eval = FALSE}
packagename_config <- function(fontsize = 10){
  if(!is.numeric(fontsize)){
    rlang::abort("Argument `fontsize` must be a number")
  }
  brew(list(fontsize = fontsize))
}
```

An additional benefit of writing a wrapper function is to allow users to provide
their own `config` file. The easiest way to do this is to support a `file`
argument within your own function, then pass this directly to `brew`:

```{r, eval = FALSE}
packagename_config <- function(file){
  brew(file = file)
}
```

This approach is risky, however, as it doesn't allow any checks. An alternative
is to intercept the file, run your own checks, then pass the result as data:

```{r, eval = FALSE}
packagename_config <- function(file){
  data <- potions::read_config_file(x)
  # add any checks to `data` that are needed here
  if(length(names(data)) != length(data)){
    rlang::abort("Not all entries are named!")
  }
  # pass to `brew`
  brew(data)
}
```


### Auto-import of configuration settings
A final - and entirely optional - step might be to integrate the above steps to
support automatic configuration imports. For example, if you developed a package 
called `somepackage`, we could tell our users that any file named 
`somepackage.yml` 

```{r, eval=FALSE}
.onLoad <- function(libname, pkgname) {
  if(pkgname == "somepackage") {
    if(file.exists("somepackage.yml")){
      potions::brew(file = "somepackage.yml", 
                    .pkg = "somepackage")  
    }else{
      potions::brew(.pkg = "somepackage")  
    }
  }
}
```
This approach has some advantages:
- users don't have to do any work to apply their configuration settings every time a package is loaded
- users can easily disable configuration import, by removing `somepackage.yml` from the working directory
- there is unlikely to be a conflict where incorrect configuration settings are imported, because the filename requirements are deliberately restrictive

However, any approach that moves information around without the user 
specifically requesting it comes with risks, especially where that information
is itself sensitive. Ergo some care is needed with this method.
